# .github/workflows/docker-build-push.yml
#
# 这个 GitHub Action Workflow 用于自动构建 Docker 镜像并将其推送到私有仓库或 Docker Hub。
#
# 触发条件:
# 1. schedule: 定时触发，默认为每天 UTC 时间 00:00 (北京时间 08:00)。
# 2. workflow_dispatch: 允许您在 GitHub 仓库的 "Actions" 标签页中手动触发此流程。
#
# 所需的 GitHub Secrets:
# - REGISTRY_URL: 您的私有仓库 URL (例如: 'ghcr.io' 或 'your-registry.example.com')。如果使用 Docker Hub, 请留空或不设置。
# - REGISTRY_USERNAME: 登录仓库的用户名。
# - REGISTRY_TOKEN: 登录仓库的访问令牌或密码。
# - REGISTRY_IMAGE_NAME: 您希望推送的镜像名称 (例如: 'your-username/your-repo-name')。

name: Build and Push Docker Image

on:
  workflow_dispatch: # 允许手动触发
  schedule:
    - cron: '0 5 * * 0' # 每周日 UTC 05:00 运行

jobs:
  build-and-push:
    runs-on: ubuntu-latest # 使用最新的 Ubuntu 运行器
    strategy:
      matrix:
        pg_version: ['15','16','17','18','latest'] # 定义要构建的 PostgreSQL 版本 

    steps:
      # 第一步：检出代码
      # 拉取您的仓库代码，以便 Action 可以访问 Dockerfile 和 init.sql
      - name: Checkout repository
        uses: actions/checkout@v4

      # 第二步：设置 QEMU (可选, 但推荐)
      # 这是一个很好的实践，用于支持多平台构建 (虽然本示例中未显式使用)
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      # 第三步：设置 Docker Buildx
      # Buildx 是一个 Docker CLI 插件，用于扩展构建功能
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 第四步：登录到容器仓库
      # 动态登录到 Docker Hub 或私有仓库
      # 如果 REGISTRY_URL Secret 未设置, 'registry' 参数将为空, 默认为 Docker Hub
      - name: Log in to Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.REGISTRY_URL }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_TOKEN }}

      # 第五步：动态设置镜像标签和构建参数
      - name: Set image tags and build args
        id: meta
        run: |
          local_pg_version="${{ matrix.pg_version }}"
          
          # DOCKERFILE_VERSION_ARG 是传递给 Dockerfile 的 'version' 参数.
          # 它必须是一个版本号 (例如 '15', '16'), 因为 Dockerfile 使用它来拉取 'postgres:NN-bookworm' 和 'postgresql-server-dev-NN'.
          #
          # IMAGE_TAG_SUFFIX 是我们最终推送到仓库的 Docker 标签 (例如 ':15', ':latest').
          
          if [ "$local_pg_version" == "latest" ]; then
            # 当矩阵要求 'latest' 时:
            # 1. 我们假设 '18' 是当前的最新版，并用它来构建。
            #    (如果 'latest' 变为 '19'，您需要回来将这里更新为 '19')
            echo "DOCKERFILE_VERSION_ARG=18" >> $GITHUB_OUTPUT
            # 2. 我们将最终的镜像标签设为 ':latest'。
            echo "IMAGE_TAG_SUFFIX=:latest" >> $GITHUB_OUTPUT
          else
            # 对于所有数字版本 (例如 '15'):
            # 1. 我们直接使用该版本号进行构建。
            echo "DOCKERFILE_VERSION_ARG=${local_pg_version}" >> $GITHUB_OUTPUT
            # 2. 我们使用该版本号作为标签。
            echo "IMAGE_TAG_SUFFIX=:${local_pg_version}" >> $GITHUB_OUTPUT
          fi

          # 根据是否设置了私有仓库 URL 来构建完整的镜像推送路径
          if [ -z "${{ secrets.REGISTRY_URL }}" ]; then
            # Docker Hub (没有 registry-url)
            echo "IMAGE_TAGS=${{ secrets.REGISTRY_IMAGE_NAME }}${IMAGE_TAG_SUFFIX}" >> $GITHUB_OUTPUT
          else
            # 私有仓库
            echo "IMAGE_TAGS=${{ secrets.REGISTRY_URL }}/${{ secrets.REGISTRY_IMAGE_NAME }}${IMAGE_TAG_SUFFIX}" >> $GITHUB_OUTPUT
          fi

      # 第六步：构建并推送 Docker 镜像
      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: . # Dockerfile 所在的上下文路径 (仓库根目录)
          file: ./Dockerfile # Dockerfile 的文件路径
          push: true # 确认执行推送操作
          
          # 从上一步动态获取镜像标签
          tags: ${{ steps.meta.outputs.IMAGE_TAGS }}
          
          build-args: | # 传递给 Dockerfile 的构建参数  # 使用上一步动态设置的版本号
            version=${{ steps.meta.outputs.DOCKERFILE_VERSION_ARG }}
            # 您也可以在这里覆盖 APT 镜像和 GitHub 代理，例如:
            # APT_MIRROR=http://mirrors.aliyun.com
            # GITHUB_PROXY_PREFIX=https://ghproxy.com/

